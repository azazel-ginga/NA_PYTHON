#coding = utf - 8



'''
线程的生命周期


当线程被创建以后，它既不是一启动就进入执行状态的，也不是一直处于执行状态的，在线程的生命周期中，它要经过新建(New)
就绪(Ready)、运行(Running)、阻塞(Blocked)和死亡(Death)5种状态。尤其是当线程启动以后，它不可能一直“霸占”着
CPU独自运行，所以CPU需要在多个线程之间切换，于是线程状态也会多次在运行、就绪之间转换。



新建和就绪状态

当程序创建了一个Thread对象或者Thread子类的对象之后，该线程就处于新建状态，和其他的Python对象一样，此时的线程
对象并没有表现出任何线程的动态特征，程序也不会执行线程执行体。

当线程对象调用start()方法之后，该线程处于就绪状态，Python解释器会为其创建方法调用栈和程序计数器，处于这种状态
中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于Python解释器中线程调度器的调度。

在调用线程对象的start()方法后，该线程立即进入就绪状态---相当于“等待执行”，但该线程并未真正进入运行状态。


***只能对处于新建状态的线程调用start()方法。也就是说，如果程序对同一个线程重复调用start()方法，将引发RuntimeError异常


运行和阻塞状态
如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态。如果计算机只有一个CPU，那么在任何
时刻只有一个线程处于运行状态。当然，在一个具有多处理器的机器上，将会有多个线程并行(Parallel)执行；当线程数大于处理器数
时，依然会存在多个线程在同一个CPU上轮换的情况

当一个线程开始运行之后，它不可能一直处于运行状态(除非它的线程执行体足够短，瞬间就执行结束了)，线程在运行过程中需要被中断
目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用策略。对于采用抢占模式调度策略的系统而言，系统会给每一个
可执行的线程一个小时间端来处理任务；当该时间段用完后，系统会剥夺该线程所占用的资源，让其他线程获得执行机会。在选择下一个线程
时，系统会考虑线程的优先级。

所有现代的桌面和服务器操作系统都采用抢占式调度策略，但一些小型设备如手机等则可能采用协作式调度策略，在这样的系统中，只有当
一个线程调用了它的sleep()或yield()方法之后才会放弃其所占用的资源---也就是必须由该线程主动放弃其所占用的资源。

当发生如下情况时，线程将会进入阻塞状态:
1.线程调用了sleep()方法主动放弃其所占用的处理器资源
2.线程调用了一个阻塞式I/O方法，在该方法返回之前，该线程被阻塞
3.线程试图获得一个锁对象，但该锁对象正被其他线程所持有。
4.线程在等待某个通知(Notify)
当前正在执行的线程被阻塞后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态，而不是
运行状态。也就是说，被阻塞的线程的阻塞解除后，必须重新等待线程调度器再次调度它。

针对上面集中情况，当发生如下特定的情况时，可以解除阻塞，让该线程重新进入就绪状态。
1.调用sleep()方法的线程经过了指定的时间
2.线程调用的阻塞式I/O方法已经返回
3.线程成功的获得了试图获取的锁对象。
4.线程正在等待某个通知时，其他线程发出了一个通知。
线程从阻塞状态只能进入就绪状态，无法直接进入运行状态。就绪和运行状态之间的转换通常不受程序控制，而是由系统调度所决定的，当
处于就绪状态的线程获得处理器资源时，该线程进入运行状态;当处于运行状态的线程失去处理器资源时，该线程进入就绪状态。

线程死亡
线程以如下三种方式结束，结束后就处于死亡状态
1.run()方法或代表线程执行体的target函数执行完成，线程正常结束。
2.线程抛出一个未捕获的Exception
3.线程抛出一个Error

***当主线程结束时，其他线程不受任何影响，并不会随之结束。一旦子线程启动起来后，它就拥有和主线程相同的地位，它不会受主
线程的影响。

为了测试某个线程是否死亡，可以调用线程对象的is_alive()方法，当线程处于就绪、运行、阻塞三种状态时，该方法返回True;当
线程处于新建、死亡两种状态时，该方法返回False。

***不要试图对一个已经死亡的线程调用start()方法使它重新启动，死亡就是死亡，该线程将不可再次作为线程运行。

'''

#下面程序尝试对处于死亡状态下的线程再次调用start()方法
import threading

#定义action函数准备作为线程执行使用

def action(max):
	for i in range(max):
		print(threading.current_thread().name + " " + str(i))
#创建线程对象
sd = threading.Thread(target=action,args=(100,))
for i in range(300):
	#调用threading.current_thread()函数获取当前线程
	print(threading.current_thread().name + " " + str(i))
	if i == 20:
		#启动线程
		sd.start()
		#判断线程启动后是否存活，使用is_alive()的值来判断，输出True
		print(sd.is_alive())

#当线程处于新建、死亡两种状态时，is_alive()方法返回False
#当i > 20时，该线程肯定已经启动过了，如果sd.is_alive()为False
#那么就处于死亡状态了
if i > 20 and not(sd.is_alive()):
	#试图再次开启线程
	sd.start()

'''
运行上面的程序将会引发一个RuntimeError异常，这表明处于死亡状态的线程无法再次运行

***不要对处于死亡状态的线程调用start()方法，程序只能对处于新建状态的线程调用start()方法
对处于新建状态的线程两次调用start()方法也是错误的。它们都会引发RuntimeError异常。
'''
